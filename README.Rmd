---
output: github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```



# funr: Functional mapping with parallelism and progress bars

## Overview

`funr` is a lightweight, dependency-free toolkit designed to extend and modernize R's functional programming capabilities. It provides simple yet powerful tools to map, walk, reduce, compose, cross-validate, and parallelize computations, with native support for progress bars and works naturally with base R data structures without requiring conversion to special classes or tibble formats. It uses only base R with `parallel`, making it easy to integrate into R scripts, pipelines, or legacy codebases. 

## Why funr?

Built on base R with no heavy dependencies, `funr` streamlines functional worflows with intuitive syntax and built-in support for parallelism and progress bars. it design keep things simple and readable. 

## Key features

- `fmap()`: element-wise mapping
- `fmapn()`: **n**-ary zipped mapping
- `fmapr()`: **r**ow-wise data frame mapping
- `fmapc()`: **c**olumn-wise mapping
- `fmapg()`: **g**roup-wise processing
- `fwalk()`: for side-effect actions
- `fcv()`: **c**ross-**v**alidation engine
- `fapply()`: parallel + progress-enabled apply
- `frepeat()`, `fcompose()`, `freduce()`: functional composition and iteration


## Comparison with similar packages

### Feature coverage

| Feature              | `funr`                      | `pbapply`    | `purrr`                       | Base R                         |
| -------------------- | --------------------------- | ------------ | ----------------------------- | ------------------------------ |
| Element-wise map     | `fmap()`                    | `pblapply()` | `map()`                       | `lapply()`                     |
| Multi-arg mapping    | `fmapn()`                   | —            | `pmap()`                      | `Map()` / `mapply()`           |
| Row-wise mapping     | `fmapr()`                   | —            | `pmap(df, ...)`               | `apply(df, 1, ...)`            |
| Column-wise mapping  | `fmapc()`                   | —            | `imap()` *(not column-aware)* | `lapply(df, ...)`              |
| Grouped operations   | `fmapg()`                   | —            | `map(split(...))`             | `split()` + `lapply()`         |
| Parallelism          | Built-in via `ncores`       | via `cl`     | via `furrr`                   | `mclapply()` (Unix)            |
| Progress bars        | Built-in native timer bar   | Built-in     | Not supported                 | None                           |
| Cross-validation map | `fcv()`                     | —            | —                             | manual loop                    |
| Side-effect mapping  | `fwalk()`                   | —            | `walk()`                      | `lapply()` + discard           |
| Functional utilities | `freduce()`, `fcompose()`\* | —            | `reduce()`, `compose()`       | `Reduce()`, `compose()` (rare) |

> \*Coming soon in your roadmap: `freduce()`, `fcompose()` etc.

---

### Syntax equivalence

| Task                     | `funr` Example                          | `pbapply`            | `purrr` Example               | Base R                     |
| ------------------------ | --------------------------------------- | -------------------- | ----------------------------- | -------------------------- |
| Map square               | `fmap(1:5, \(x) x^2)`                   | `pblapply(1:5, ...)` | `map(1:5, ~ .x^2)`            | `lapply(1:5, ...)`         |
| Map with 2 args          | `fmapn(list(1:3, 4:6), \(x,y) x+y)`     | —                    | `pmap(list(a,b), ~ x+y)`      | `Map(\(x,y) x+y, a, b)`    |
| Map over data frame rows | `fmapr(df, \(row) row$a + row$b)`       | —                    | `pmap(df, ...)`               | `apply(df, 1, ...)`        |
| Map over data frame cols | `fmapc(df, \(x, name) mean(x))`         | —                    | `imap(df, ...)`               | `lapply(df, ...)`          |
| Grouped map              | `fmapg(df, f, by = "group")`            | —                    | `map(split(df, df$group), f)` | `split()` + `lapply()`     |
| Parallel + progress      | `fmap(x, f, ncores = 4, pb = TRUE)`     | `pblapply(x, f, cl)` | `future_map(x, f)`            | `mclapply(x, f)` (Unix)    |
| Repeat simulation        | `frepeat(times = 100, expr = rnorm(1))` | —                    | *(manual loop)*               | `replicate(100, rnorm(1))` |
| Walk with side effects   | `fwalk(letters, cat)`                   | —                    | `walk(letters, cat)`          | `lapply(letters, cat)`     |
| Reduce                   | `freduce(1:5, \`+\`)\` *(planned)*      | —                    | `reduce(1:5, \`+\`)\`         | `Reduce(\`+\`, 1:5)\`      |

---

### Function reference table

| Function    | Main Arguments                        | Output Type | Description                                                     |
| ----------- | ------------------------------------- | ----------- | --------------------------------------------------------------- |
| `fmap()`    | `.x`, `.f`, `ncores`, `pb`            | list        | Map function `.f` over elements of `.x`                         |
| `fmapn()`   | `.l`, `.f`, `ncores`, `pb`            | list        | Map `.f` over multiple aligned lists of arguments               |
| `fmapr()`   | `.df`, `.f`, `ncores`, `pb`           | list        | Map `.f` over each row of a data frame (as named list)          |
| `fmapc()`   | `.df`, `.f`, `ncores`, `pb`           | list        | Map `.f(column, name)` over each column of a data frame         |
| `fmapg()`   | `.df`, `.f`, `by`, `ncores`, `pb`     | list        | Map `.f(group_df)` over groups defined by `by`                  |
| `fwalk()`   | `.x`, `.f`, `ncores`, `pb`            | NULL        | Side-effect-only version of `fmap()`                            |
| `frepeat()` | `times`, `expr`, `.x`, `ncores`, `pb` | list/array  | Repeat a function or expression multiple times                  |
| `fcv()`     | `.splits`, `.f`, `ncores`, `pb`       | list        | Map `.f` over a list of `rsample::vfold_cv` split objects       |
| `fapply()`  | `.x`, `.f`, `ncores`, `pb`, `...`     | list        | Core backend for all parallel, progress-aware mapping functions |



## Philosophy

`funr` promotes a minimalist but powerful approach to data transformation:

- **Functional**: All tools are pure functions.
- **Composable**: Can be easily combined into pipelines.
- **Transparent**: No magic, only base R principles.
- **Reproducible**: Built for batch workflows, simulations, CV.

## Why no formula interface like `~ .x + .y`?

While `funr` draws inspiration from `purrr`, it intentionally avoids supporting the formula-based anonymous function syntax (e.g., `~ .x + 1`) for now.

This decision is based on:

- Keeping dependencies minimal (no reliance on `rlang`)
- Avoiding non-standard evaluation that can confuse new users
- Encouraging explicit, readable code using `function(x) { ... }` style

We may consider adding tidy evaluation support (e.g., with quosures or `rlang::as_function`) in a future release. However, the current philosophy favors clarity, portability, and simplicity.


## Installation

```{r}
# install.packages("funr") # when available
#remotes::install_github("yourusername/funr")
```

## Example 1 

```{r}
#library(funr)
#slow_fn <- function(x) { Sys.sleep(0.01); x^2 }

# Parallel with progress
#res <- fapply(1:100, slow_fn, ncores = 4, pb = TRUE)
```


## Example 2 

```{r, eval=FALSE}
library(tidymodels)
library(dplyr)
#library(funr)  

set.seed(123)

# -------------------------------
# Step 1: Define model + workflow
# -------------------------------
# This sets up a decision tree classification model using tidymodels
workflow <- workflows::workflow() |>
  add_model(
    decision_tree() |>
      set_engine("rpart") |>
      set_mode("classification")
  ) |>
  add_formula(Species ~ .)

# ------------------------------------
# Step 2: Define evaluation for 1 fold
# ------------------------------------
# Takes a split object and returns metrics for the fitted model
evaluate_split <- function(split) {
  fit <- fit(workflow, analysis(split))
  preds <- predict(fit, assessment(split)) |>
    bind_cols(assessment(split) |> select(Species))
  metrics(preds, truth = Species, estimate = .pred_class)
}

# ----------------------------------------------------
# Step 3: Full CV pipeline using `funr` piping tools
# ----------------------------------------------------
# Explanation:
# - `frepeat()` repeats cross-validation 10 times
# - `fcv()` applies `evaluate_split()` to each fold in parallel
# - `fmap()` filters results to keep only "accuracy" rows
# - `bind_rows()` and `summarize()` compute mean and SD
mean_accuracy <- iris |>
  vfold_cv(v = 10) |> #funr
  pull(splits) |>
  frepeat(expr = function(x) fcv(x, evaluate_split, ncores = 4), times = 10) |> #funr
  unlist(recursive = FALSE) |>
  fmap(function(x) dplyr::filter(x, .metric == "accuracy")) |> #funr
  bind_rows() |>
  summarize(mean = mean(.estimate), sd = sd(.estimate))

# Print result
print(mean_accuracy)

```

## `funr` development TODO

### Design and API consistency

* [X] Unify function argument naming conventions (e.g., use `.f` or `fun`, `x` instead of `X`) > prefer lowercase and functional style
* [X] Consolidate and centralize helper functions (`.check_fapply_args`, `splitpb`)
* [X] Move progress bar helpers (`funr_progress_bar` and others) to `R/utils.R`

### Package structure and documentation

* [X] Add `@docType package` and `@keywords internal` where relevant
* [X] Add `.onLoad()` to initialize options (`pboptions`)
* [X] Document all functions using **Roxygen2** (`@param`, `@return`, `@examples`, `@export`)
* [X] Ensure all exported functions have complete `@examples` and `@return` tags
* [X] Proofread and polish `DESCRIPTION` Title and Description
* [X] Add `Authors@R` field with full name, role, and email
* [X] Add License declaration and check license of any reused code

### Testing and validation

* [X] Write unit tests for all core functions (`fmap*`, `fapply`, `frepeat`, `fcv`, ...)
* [X] Ensure acceptable test coverage with `testthat`
* [X] Run `devtools::check()` and fix all NOTES, WARNINGS, ERRORS



### Documentation and usability

* [X] Update `README.md` with consistent examples and clear installation instructions
* [ ] Add comparison tables to README (vs `purrr`, `pbapply`, base R)
* [ ] Create minimal reproducible example for each exported function
* [ ] Add CONTRIBUTING.md or contribution section in README
* [ ] Create vignettes:

  * [ ] `benchmarking.Rmd` – benchmark vs `furrr`, `pbapply`
  * [ ] `funr-vs-purrr.Rmd` – comparison and philosophy
  * [ ] `funr-overview.Rmd` – design goals and examples


* [ ] Review syntax equivalence table in the README to ensure accuracy and consistency
* [ ] Add illustrative examples for each mapping function to clarify usage and behavior

Let me know if you'd like to combine them into a single checklist item.



### GitHub integration

* [ ] Add GitHub URL with `usethis::use_github_links()`
* [ ] Add badges: build status, coverage, license, CRAN version
* [ ] Add `LICENSE.md`, `CODE_OF_CONDUCT.md`, and optionally `NEWS.md`


